{"type":"auditAdvisory","data":{"resolution":{"id":1555,"path":"snyk>snyk-docker-plugin>tar-stream>bl","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"3.0.0","paths":["snyk>snyk-docker-plugin>tar-stream>bl"]}],"id":1555,"created":"2020-09-08T18:24:53.638Z","updated":"2020-09-08T19:15:40.690Z","deleted":null,"title":"Remote Memory Exposure","found_by":{"link":"","name":"chalker","email":""},"reported_by":{"link":"","name":"chalker","email":""},"module_name":"bl","cves":[],"vulnerable_versions":"<1.2.3 || >2.0.0 < 2.2.1 || >=3.0.0 <3.0.1 || >= 4.0.0 <4.0.3","patched_versions":">=1.2.3 <2.0.0 || >=2.2.1 <3.0.0 || >=3.0.1 <4.0.0 || >=4.0.3","overview":"A buffer over-read vulnerability exists in bl <4.0.3, <3.0.1 <2.2.1 and <1.2.3 which could allow an attacker to supply user input (even typed) that if it ends up in consume() argument and can become negative, the BufferList state can be corrupted, tricking it into exposing uninitialized memory via regular .slice() calls.","recommendation":"Upgrade to version 4.0.3, 3.0.1, 2.2.1 or 1.2.3.","references":"- https://github.com/advisories/GHSA-pp7h-53gx-mx7r\n- https://nvd.nist.gov/vuln/detail/CVE-2020-8244\n- https://github.com/rvagg/bl/commit/8a8c13c880e2bef519133ea43e0e9b78b5d0c91e\n- https://github.com/rvagg/bl/commit/d3e240e3b8ba4048d3c76ef5fb9dd1f8872d3190\n- https://github.com/rvagg/bl/commit/dacc4ac7d5fcd6201bcf26fbd886951be9537466\n- https://hackerone.com/reports/966347","access":"public","severity":"high","cwe":"CWE-126","metadata":{"module_type":"","exploitability":5,"affected_components":""},"url":"https://npmjs.com/advisories/1555"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1556,"path":"node-fetch","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"2.6.0","paths":["node-fetch"]}],"id":1556,"created":"2020-09-10T17:55:53.926Z","updated":"2020-09-10T17:55:53.926Z","deleted":null,"title":"Denial of Service","found_by":{"link":"","name":"Unknown","email":""},"reported_by":{"link":"","name":"Unknown","email":""},"module_name":"node-fetch","cves":["CVE-2020-15168"],"vulnerable_versions":"< 2.6.1 || >= 3.0.0-beta.1 < 3.0.0-beta.9","patched_versions":">=2.6.1 <3.0.0-beta.1|| >= 3.0.0-beta.9","overview":"Node Fetch did not honor the size option after following a redirect, which means that when a content size was over the limit, a FetchError would never get thrown and the process would end without failure.\n\nFor most people, this fix will have a little or no impact. However, if you are relying on node-fetch to gate files above a size, the impact could be significant, for example: If you don't double-check the size of the data after fetch() has completed, your JS thread could get tied up doing work on a large file (DoS) and/or cost you money in computing.","recommendation":"Upgrade to version 2.6.1 or 3.0.0-beta.9","references":"- https://github.com/node-fetch/node-fetch/security/advisories/GHSA-w7rc-rwvf-8q5r","access":"public","severity":"low","cwe":"CWE-400","metadata":{"module_type":"","exploitability":3,"affected_components":""},"url":"https://npmjs.com/advisories/1556"}}}
